★ 챕터1장(다른 챕터와는 다르게 컴퓨터 네트워크의 감을 읽히고, 용어를 습득하는데 목적을 가진다.)
※ 네트워크 코어
- 네트워크 코어
	+ 서로 연결된 라우터들의 망구조로 Global ISP, Regional ISP가 있다.
	+ 패킷 스위칭 방식은 shared 방식으로 전송되며 한 패킷이 전송되면 다른 사람이 쓸 수 있게 된다. 
	+ 또한 호스트가 에플리케이션 메세지를 패킷 단위로 쪼갠다.


- Packet-switching: store-and-forward
	+ 라우터에서 완전히 패킷하나가 다 차야 다음단계로 넘어간다. 예로, 약 2초소요 (L/R)
	+ end-end delay = 2 * L/R 이다. ex) L = 7.5, R = 1.5 답은 5초 *2 = 10초


- Packet-switching: queueing delay, loss
	+ 큐에 기다리는 시간을 queueing delay라고 부른다.
	+ 패킷은 큐에 저장되고 출력 링크 상에서 전송 되기를 기다림
	+ 큐의 메모리가 꽉 차 있는 경우 패킷은 손실됨


- 라우터와 라우터로 연결되어있는 네트워크 코어에는 두 가지 중요한 키가 되는 기능
	+ 라우팅은 패킷을 취하게될 출발지부터 도착지 부터 경로를 결정하는 것을 말한다.
	+ 이 때, 라우팅 알고리즘을 사용하게 되면서, local forwarding table을 확인하여 링크대로 이동하게 된다. 또한 header value는 해당 주소 값을 의미한다.
	+ forwarding은 라우터의 입력에서 적절한 라우터 출력으로 패킷을 이동하는 것을 말한다.
	+ forwarding은 말 그대로 라우팅이 경로를 결정해주면, 패킷을 전송을 할 수 있게 이동하게 해주는 역할을 한다. (output link)


- 서킷 교환(회선 교환 or Circuit Switching)
	+ End-end간의 자원을 할당하고 예약하는 방식을 말한다.
	+ 물리적 링크를 4조각 난 것처럼 한 이유는 조그만한 채널을 나눴다고 생각하면 된다.
	+ 이것은 dedicated 방식을 사용한다. 또한 성능을 보장해준다. (속도▲) 
	+ 자신의 호가 사용되지 않으면 분할된 자원은 idle 상태이다. (다른 호와 no sharing) ★★★★★


- 서킷 교환 FDM(Frequency-Division Multiplexing) vs TDB(Time-Division Multiplexing)
	+ FDM은 링크에서 사용가능한 frequency를 쪼개서 연결된 시간동안 할당된 대역만 사용하게 함. 그래서 시간은 의미가 없다.
	+ TDM은 time을 쪼개서 각자 번갈아 가면서 다른 시간대에 사용자가 사용하는 방식을 사용하게 함. 그래서 frequency는 의미가 없다.


- 패킷 교환 vs 회선 교환
	+ 패킷 스위칭은 더 많은 사용자들을 사용하게 해준다.
	+ 예) 1Mb/s 선이 있고 각 사용자가 100kb/s 를 사용한다. 그리고 시간의 10%만 사용한다.(90%는 idle상태(전화를 할 때 상대방이 말을 할 때, 듣는 사람은 idle 상태이므로))
	+ 서킷 스위칭은 10명만 가능하고, 패킷 스위칭은 35명의 유저일 경우, 전송을 시도하는 사용자가 10명보다 초과할 확률은 0.0004보다 더 작다. 그 만큼 사용자를 더 많이 받을 수 있다. 다만 느려짐.
	+ 패킷 스위칭이 서킷 스위칭을 완전히 누를 수 있느냐? 그건 아니다. 다만, Bursty data : 한꺼번에 몰려오는 스타일에 좋다. 또한 no call setup단계가 없어서 좋다.(서킷은 3단계)
	+ 혼잡 가능성(Excessive congestion possible)는 패킷 딜레이와 손실이 생길 수 있다.혼잡 제어를 위한 protocol 이 필요하게 되고, 그에 따라 돈이 든다. 또한 대역폭 구매가 필요해진다. 
	+ 패킷 스위칭에서 어떻게 하면 서킷 비슷한 방식을 할 수 있을까?
	+ reserved resources : 예약하는 방식 vs On-demand allocation  : 필요에 의해 할당 (예약 안 하는 시스템) 대부분의 시스템이 있다.


- 인터넷 구조: 네트워크들의 네트워크
	+ 종단 시스템은 접속 ISP (access (access Internet Service Provider) Internet Service Provider)를 통해 인터넷에 연결한다. (ex 통신 회사, 회사, 대학)
	+ 접속 ISP들은 서로 상호 연결을 해야 한다. 그래서 네트워크의 네트워크 형태의 복잡한 구조로 진화	한다. 
	+ 수 백만 개의 접속 ISP를 어떻게 연결하는가? 또한 옵션: 각 접속 ISP들끼리 서로 연결?
	+ scale을 감당할 수 없다.(능동적으로) 방식은 100% 불가능 하다.
	+ 그래서 해결책으로 global ISP를 두고 지역별로 묶어서 받는다. 그리고 라우터들 끼리도 연결해주는 방식이다.
	+ 이렇게 함으로써, 링크들의 갯수와 연결의 갯수가 훨씬 줄어들었다.
	+ 그러나, 한 글로벌 ISP가 수익을 낸다면, 다른 새로운 글로벌 ISP도 생겨 경쟁을 할 것이다.
	+ 그리고 우리는 글로벌 ISP들 간에도 상호 연결되어야 한다. (peering link)

	+ 또한 internet exchange point(IXP)을 사용하여 먼곳까지 상호작용을 빠르게 할 수 있다. (사업자들이 자발적으로 건설함. 많은 사용자들을 이끌기 위해서)
	+ Regional net도 나오게 되고, 직접 네트워크를 제공하는 구글, 마이크로소프트, 아카나미 등이 있다. (Content provider network)
	+ 오늘날의 인터넷 – 네트워크의 네트워크 –은 복잡하며 12개 정도의 1-계층 ISP들과 수십만개의 하위 계층 ISP들로 구성한다.
	+ 1-계층 ISP (Sprint, AT&T, NTT)는 국가, 국가 간의 담당한다. 또한 예로는 구글이 있는데 이렇게 하는 이유는 비용 절감에 있다.



※ 패킷 지연과 손실 발생
- 패킷은 라우터의 큐(버퍼)에서 대기
	+ 패킷 도착 속도가 출력 링크 용량을 초과한 경우, 패킷들은 자신의 순서를 기다린다.
	+ 패킷이 전송하거나, queuein할 때 딜레이가 발생한다.


- 패킷 지연 유형
	+ 노드 처리 지연 (nodal processing delay): 에러가 있는지 확인하는데 걸리는 시간과 output link를 
	결정하는데 걸리는 시간이다. (msec보다 작다)
	+ 큐잉 지연 (queuing delay): 전송될 때 까지의 기다리는 시간이다. 또한 라우터 혼잡 수준에 따라 
	시간이 좌우된다.
	+ 전송 지연 (transmission delay): 라우터에서 링크에 실는데 걸리는 시간이다. 
	(L/R) packet length(bits)/link bandwidth(bps)
	+ 전파 지연 (propagation delay): 출발지부터 도착지까지 걸리는 시간이다.
	(d/s) length of physical link(d)/propagation speed(~2x10^8 m/sec)
	+ 전송 지연과 전파 지연이 매우 다르다는 것을 기억하자.


- Caravan analogy
	+ 예1) 함께 여행하는 10대의 자동차 대열 (패킷), 1 대의 자동차 (비트), 100 km 마다 요금 계산소 (라우터)
	+ 예1) 각 요금 계산소는 한 대의 자동차 서비스(전송)에 12초 걸림, 자동차는 시속 100 km 속도로 
	주행(전파)
	+ 예1) 전체 자동차를 고속도로로 내 보내는데 걸리는 시간은? 12초 x 10대 = 120초 = 2분 
	(전송 지연)
	+ 한 자동차가 한 요금 계산소에서 다음 요금 계산소로 이동하는 시간 
	100 km / (100 km/hour) = 1시간 (전파지연)
	+ 자동차 대열이 모두 두 번째 요금 계산소 도착하는데 걸리는 시간은? 
	전송 지연 + 전파 지연 = 62분
	+ 예2) 자동차는 시속 1000 km 1000 km 속도로 주행, 요금 계산소는 1분에 1대 서비스
	+ 예2) 한 자동차가 한 요금 계산소에서 다음 요금 계산소로 이동하는 시간 
	100 km / (1000 km/hour) = 6분 (전파지연)
	+ 예2) 7분 후에는 첫 번째 자동차가 두 번째 요금 계산소에 도착 => 3대의 자동차는 여전히 첫 번째 요금 계산소에서 대기 중
	+ 모든 패킷이 첫 번째 라우터에서 전송되기 전에 패킷의 첫 번째 비트가 두 번째 라우터에 
	도착할 수 있음
	+ 예1은 장거리 망, 예2는 단거리 망으로 많이 벌어진다.
- Queueing delay (재 방문)
	+ 트래픽 강도(La/R)가 1에 가까워 지면 무한에 가까워 진다. (무한시간에 기다려야 된다는 점)
	+ R은 link bandwidth(bps)이고, L은 packet length(bits)이고, a는 패킷 도착 평균율, La는 비트가 큐에 도착하는 평균율이다.
	+ La/R ~ 0에 가까우면 평균 큐잉 지연은 작고, La/R -> 1에 접근하면 큐잉 지연은 아주 커짐
	+ La/R > 1보다 커지면 서비스 용량을 초과하여 평균 지연이 무한대로 커짐
- "실제" 인터넷 딜레이와 경로
	+ Traceroute 진단 프로그램은 소스부터 라우터까지 딜레이를 측정해서 제공해준다.
	+ 이프로그램의 일은 3개의 패킷을 보낸 후, 응답 패킷을 전송하게 되면, 송신자는 패킷 송신과 응답 사이 시간을 측정한다.
	+ ***는 패킷이 손실되었거나, 라우터가 응답하지 않은 상태를 말한다.
	+ 갑자기 22ms --> 100ms 가 걸리면 바다를 건너갔다는 소리이다.
- 패킷 손실
	+ 앞에서 큐(버퍼)가 무한대 패킷을 저장한다고 가정한다.
	+ 실제는 라우터의 큐 용량이 유한하고, 큐가 차게되어 도착한 패킷을 저장할 수 없으면 패킷을 버리게 되어 (drop), 패킷을 잃어 버림 (lost)
	+ 잃어 버린 패킷은 이전 노드나 출발지 종단에서 재전송 될 수 있음

- 처리율 (throughput)
	+ 송수신 간에 비트가 전송되는 비율(속도, 비트/초)
	+ 순간적인 처리율 (instantaneous throughput): 주어진 순간에 전송 비율, 파일 수신 시 파일을 수신하는 비율
	+ 평균 처리율 (average throughput): 주어진 시간 동안의 전송 비율, 파일의 크기가 F이고 모두 수신하는데 T초 걸리면 , F/T 비트/초가 평균 처리율
	+ Rs bits/sec 최대 처리률 = capacity
	+ Rs < Rc 중에 누가 평균 처리율이 결정되나? Rs
	+ Rs > Rc 중에 누가 평균 처리율이 결정되나? Rc 
	+ 병목현상(bottleneck link ) : end-end패스에 있는 처리율을 제한한다. 즉, 위에선 Rs 아래에선 Rc가 된다. ★★★★★★
	+ 예) 10개의 클라이언트가 10개의 서버로 부터 다운로드하는 예에서 아주 작은 값에서 처리율이 결정된다. min(Rc,Rs,R/10) Rc나 Rs가 병목현상이 있다.
	+ 한쪽만 처리율을 올리는건 안좋은 예

※ 프로토콜 계층과 서비스 모델
- 프로토콜 계층
	+ 많은 요소로 구성된 인터넷은 매우 복잡한 시스템
	+ 호스트, 라우터, 다양한 링크 수준의 매체, 다양한 애플리케이션, 프로토콜, 하드웨어, 소프트웨어
	+ 네트워크의 구조(structure)의 조직화(organizing)가 가능한가? 레이어 개념에서 가능하다.


- 비행기의 여행 과정 조직화
	+ 티켓(구입) -> 수하물 (검사) -> 탑승구 (탑승)-> 활주로 이륙 -> 비행기 라우팅 -> 비행기 라우팅
	+ 비행기 라우팅 -> 활주로 착륙 -> 탑승구 (하차) -> 수하물(클레임) -> 티켓 (항의)
	+ 계층: 각 계층은 서비스를 구현한다.
	+ 자신의 계층 내부의 동작을 서비스로 구현하고, 아래 계층에서 제공되는 서비스에 의존한다.


- 계층화 이점
	+ 계층화를 통해 크고 복잡한 시스템을 관리할 수 있다.
	+ 명확한 구조화를 통해 복잡한 시스템 요소를 구분하고, 요소 간의 관계를 설정이 가능하다.
	+ 논의를 위한 계층화된 참조 모델(layered reference model)
	+ 시스템의 유지보수와 변경이 용이하다. 또한 층을 나누면 유지하거나 업데이트 하기도 쉽다.
	+ 한 계층의 서비스 구현이 변경되어도 시스템의 나머지 부분에 영향 없다.
	+ 예를 들어 탑승구의 기능 변화가 비행 시스템 나머지에 영향을 미치지 않는다.
	+ 나쁜 영향은 융통성이나 유연성이 없을 수 있다. 그 이유는 각 계층을 밟아야 하기 때문이다.


- 인터넷 프로토콜 스택(5개의 계층)
	+ application: 네트워크 응용을 보조해준다. (FTP: 파일 관련, SMTP: 메일 관련, HTTP: 웹 관련)
	+ transport: 프로세스-프로세스(process-process) 데이터 전송을 해준다. (TCP, UDP)
	+ network: 도착지에서 목적지까지 데이터 그램을 라우팅 해준다.(IP: 모인 정보를 바탕으로 처리할 수 있는 역할, routing protocols: 라우팅 정보를 모아주는 역할)
	+ link: 경로 상의 인접 네트워크 노드 간의 데이터 전송한다. 
	(Ethernet, 802.11(wifi), PPP: 직접 전송관련)
	+ physical: 매체 상에 비트 전송
	(실제 전기적 신호를 만들어서 링크 회선에 올려주는 메카니즘을 구현하는 층이다.)


- ISO/OSI 참조 모델(실제 사용할려고 만들었지만, 뜻대로 안됨)
	+ 프레젠테이션 (presentation): 교환되는 데이터의 의미를 해석하고, 데이터의 압축, 암호화, 호스트 
	내부 데이터 표시 규칙이다.
	+ 세션(session): 데이터 교환의 경계와 동기화하고, 데이터의 체킹포인트와 회복 방법을 세우는 
	수단이다.
	+ 필요하면 애플리케이션 계층에서 구현한다.


- Encapsulation(ppt 63페이지 슬라이드 쇼로 보자)
	+ 패킷 = 헤더(header) 필드 + 페이로드(payload)필드
	+ 예) 소스에서 메세지가 만들어지면, 에플리케이션에서 작은 단위로 자르게 되고, 프랜스 포트에서 
	패킷 하나하나 마다 Ht 컨트롤 정보를 붙인다. 이러한 것을 segment라고 부른다.(캡슐)
	+ 예) 네트워크 층에서는 Ht 정보는 볼 수가 없으며, (transport만 가능)  Hn을 붙이게 된다. 
	이러한 것을 datagram이라고 한다.(캡슐)
	+ 예) 링크 층에서 Hi를 붙인다. 이러한 것을 frame이라고 한다.(캡슐)
	+ 결과적으로 Hi | Hn | Ht | M 이 된다.
	+ 스위치는 link를 거치는데 붙이지는 않는다.
	+ 중간 라우터에 거칠때 캡슐을 꺼내고, 정보를 처리한 다음에 수정한 것을 다시 보내준다.
	+ Transport : destination까지 뜯어보질 못해서 직접적 통신이 이루어 진다고 한다.