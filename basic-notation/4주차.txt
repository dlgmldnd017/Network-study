★ 챕터 3장 Transport Layer
※ 비연결형 트랜스포트: UDP
- UDP(User Datagram prtocol) [RFC 768]
	+ IP에 최소 기능만 추가한다. (다중화/ 역다중화, 오류 검사)
	+ 최선형(best effort) 서비스의 UDP 세그먼트이다.(손실, 순서에 어긋나게 애플리케이션에 전달한다.)
	+ 비연결형이다. (UDP 송수신 사이에 연결을 위해 핸드셰이크를 사용하지 않는다.)
	(또한 UDP 세그먼트들은 서로 무관하게 독립적으로 다루어진다. ★★★★★)
	+ UDP를 사용하는 예는 스트리밍 멀티미디어 응용과 DNS, SNMP에 쓰여진다.
	(스트리밍 멀티미디어 응용은 손실을 감내하고, 속도에 민감하다)
	(DNS는 애플리케이션 프로토콜이며, 도메인 이름을 ip주소로 변환시키는 역할을 한다.)
	(SNMP는 네트워크 매니저를 위한 틀을 정해놓은 프로토콜이다.)
	+ UDP 상에서 신뢰적인 전송이 필요하다면, 애플리케이션 계층에서 신뢰성을 추가하거나,
	애플리케이션을 에러를 복구하는 메카니즘이 추가가 되어야 된다.
	+ 굳이 스트리밍에서 신뢰적인 전송을 요구되지 않는다.
	

- UDP 세그먼트 헤더
	+ length: 헤더를 포함한 UDP 세그먼트의 바이트 단위로 2^16까지 표시할 수 있다. (★★★★★)
	+ checksum: 오류가 난 곳을 발견하기 위해 필드를 가지고 있는 것이다.
	(UNREALIABLE인데 왜 필요하냐면, 오류가 난 것을 그대로 전달할 만큼 비상식적이지 않기 때문이다.)
	(오류가 나면 바로 버려도 되기에..)
	+ UDP를 사용하는 이유는 
	1. 지연을 유발하는 연결 설정이 없기 때문에
	2. 단순하여 송수신 측에서 연결 상태가 없기 때문에
	3. 간소한(작은) 세그먼트 헤더를 인한 작은 패킷 오버헤드이기 때문에
	4. 가장 큰 장점으로, 혼잡 제어를 하지 않아서 원하는 만큼 빨리 전달하기 때문에(★★★★★)
	--> 결론적으로는 빠른 서비스를 위해서 사용한다.


- UDP 체크섬
	+ 체크섬은 전송된 세그먼트의 오류를 검출한다.	
	(e.g., flipped bits: 0에서 1로, 또는 1에서 0으로 바뀌었을 때 오류가 발생했다는 소리)
	(이러나는 이유는 전기적 신호로 보내기에, 여의치 않은 환경에 의해 신호의 세기가 바뀌거나, 신호의 세기가 모호해지게 돼서 오류가 발생할 수 있기 때문이다. by 노이즈)
	+ 송신측
	1) 헤더를 포함한 세그먼트의 값을 16비트 정수의 열로 나누어 다 더하게 된다.
	(예로는 soruce port + dest port + length + checksum +...)
	2) 체크섬: 세그먼트 값들을 더한 값의 1의 보수이다.
	3) 체크섬 값을 UDP 체크섬 필드에 집어 넣는다.
	(넣기 전에는 값이 0된다.)
	+ 수신측
	1) 수신된 세그먼트의 체크섬 값을 계사한다.
	2) 계산된 체크섬 값이 체크섬 필드 값과 같은지를 비교한다
	(같으면 에러 없고, 다르면 에러가 있다.)
	--> 그럼에도 불구하고 에러가 발생할 수 있다.
	
	+ 만약 더했을 때, 오버플로우가 발생하게 되면, 버리지 않고 다시 처음부터 더해준다.
	(wraparound가 없을 때 까지)
	+ 그런다음 다 더했다면 1의 보수를 취해준다. 그러면 체크섬의 값이 나오게 된다.


※ 신뢰성있는 데이터 전송의 원리
- 신뢰성 있는 데이터 전송의 원리
	+ 트랜스포트와 링크, 애플리케이션 계층 모두에 중요한 문제이다.
	(네트워크에서 상위 10개(top-10) 안에 드는 중요한 문제이다.)
	+ 만약 신뢰성이 없는 채널이 적용된다면, 그 상황은 아주 복잡한 데이터 전송 프로콜이 될 것이다.
	+ 만약 신뢰성이 없거나 오류가 있는 데이터가 udt_send()로 전송이 된다면, rdt_rcv()로 받아서 
	신뢰성이 있는 데이터로 보상해주는 과정을 거쳐야 된다. (복잡성↑)
	

- 신뢰적인 데이터 전송 프로토콜 인터페이스
	+ rdt_send()는 상위 계층에서 호출하며, 수신 측의 상위 계층으로 전송할 데이터를 전달한다.
	+ udt_send()는 rdt가 호출하며, 비신뢰적인 채널을 통해 패킷을 수신 측에 전송한다.
	+ rdt_rcv()는 패킷이 채널의 수신 측에 도착하였을 때 호출한다.
	+ deliver_data()는 rdt가 호출하며, 상위 계층에 데이터를 전달한다.
	+ 만약 전화를 하는데, 상대방의 말을 잘 듣지 못하는 상황일 때, 우리(수신 측면)는 다시 한번 얘기 
	해달라고 요청한다. --> 즉, 송신 측에게 요청한다. (RELIABLE의 메카니즘이다.)


- 신뢰적인 데이터 전송 프로토콜 구축
	+ 이 절에서는 rdt의 송신, 수신 측의 개발을 단계적으로 소개한다.
	+ 가정) 단방향 데이터 전송만 고려한다. 
	(그 이유는 하나만 이해해도 반대쪽으로 똑같은 동작이기에 손쉽게 이해하기 쉽다.)
	(하지만 제어정보는 양방향으로 전송한다.)
	+ 송신사자와 수신자 동작 정의를 위해 FSM(Finite state machine)을 사용한다.
	(이“state"에서 다음 state는 다음 event에 의해 결정되어진다.)


- rdt 1.0 - 신뢰적인 채널 상의 신뢰적인 전송
	+ 하위 채널이 완전히 신뢰적이다. 라고 가정한다.
	(비트 오류가 없고, 패킷 손실도 없다.)
	+ 송신자와 수신자에 대한 분리된 FSM (단순한 형태)
	(송신자는 하위채널에 데이터 전송한다.)
	(수신자는 하위 채널로 부터 데이터를 읽는다.)
	

- rdt 2.0 - 비트 오류가 있는 채널
	+ 하위 채널에서 비트 오류(flip bits)가 발생 가능하다.
	(체크섬 사용하여 비트 오류 검출한다.)
	+ 오류로부터 손실이 일어나기 때문에, 회복하는 메카니즘이 있어야된다.
	--> 다시 송신 측에게 데이터를 요청한다.

	+ 오류 복구
	1. ACK(acknowledgment)는 수신된 패킷이 오류가 없음을 수신자가 송신자에 알린다. (bit 0)
	2. NAK(negative acknowledgement)은 수신된 패킷이 오류가 있음을 수신자가 송신자에 알린다. (bit 1)
	--> 만약 송신자가 NAK를 수신할 때, 패킷을 재전송한다.
	+ rdt 2.0의 추가 기능은 오류를 검출하며, 수신자의 피드백을 받는다. (ACK, NAK)


- rdt 2.0 - FSM 동작 정의
	+ ppt30 페이지에서부터 슬라이드 쇼 확인하자.
	+ corrupt는 오류가 발생한 것으로 만약 발생했다면, NAK이다.


- rdt 2.0 문제점
	+ ACK/NCK 패킷의 오류(corrupt) 가능성을 고려하지 않는다.
	(ACK/NCK 패킷에도 체크섬 비트를 추가하여야 된다.)
	(ACK/NCK 오류 시 송신자는 수신자에게 일어난 상황을 알 수 없다.)
	(ACK/NCK 오류 시 단순히 재전송하면 중복 패킷 발생 가능성이 있다.)
	+ 중복 패킷 해결책
	(송신자는 ACK/NCK 오류 시 현재 패킷을 재전송한다.)
	(송신자는 각 패킷에 순서 번호(시퀀스 변호)추가 한다.)★★★★★★★★★★★★★
	--> 순서 번호가 있다라면 사용자 입장에서는 신뢰성이 있다고 추측할 수 있다.
	--> 예를 들어서, 송신자에게 수신자가 ACK로 패킷 1을 잘 받았다고 처리했는데, 송신자에게 다시 또 패킷 1을 받았다면, 송신자의 오류가 발생하였다는 것을 알 수 있으며, 중복 패킷을 무시하면 된다.
	--> 수신자는 순서 번호를 조사하여 중복 패킷이면 버린다.
	
	+ stop and wait는 전송 후 대기를 뜻하며, 송신자가 패킷을 보낸 후, 수신자의 응답을 기다린다는
	방식이다. (하나 보내고 기다리고)


- rdt 2.1 정리
	+ 송신자
	1. 패킷에 순서 번호를 추가한다.
	2. (0,1) 두 개의 순서 번호 사용한다.
	3. 수신된 ACK/NAK의 오류 여부 조사한다.
	4. rdt 2.0 보다 상태 수가 2배이다. (현재 패킷이 순서 0 또는 1인지를 상태로 기억한다.)
	
	+ 수신자
	1. 수신된 패킷이 중복되었는지 조사한다.
	(올바르게 수신될 패킷의 순서번호가 0 또는 1인지를 상태가 표시)
	2. 수신자는 마지막으로 보낸 ACK/NAK가 송신자 측에서 제대로 받았는지 알지 못한다.


- rdt 2.2 - NAK 없는 프로토콜
	+ NAK 없이 ACK만 사용한다는 점만 제외하고 rdt 2.1의 기능과 같다.
	+ 수신자는 NAK 대신 마지막에 올바르게 수신된 패킷에 대한 ACK를 보낸다.
	(수신자는 ACK 패킷에 순서 번호를 명시해야 한다.)
	(예를 들어서, 패킷 0번을 잘 받았다면 ACK 0번을 잘 받았다고 보낸다. 그러나 패킷 1번이 오류가
	있다면, NAK를 보내는 대신, ACK 0을 보낸다. 그럼 송신자 측에서 중복된 ACK를 받으면
	NAK와 같은 동작을 하게 된다.)
	+ 송신자 측에서 중복된 ACK를 받으면 NAK와 같은 동작을 수행한다.
	(현재 패킷을 재전송한다.)


- rdt 3.0 - 오류와 손실이 있는 채널
	+ 하위 채널에서의 패킷들(데이터, ACK)의 손실이 발생할 수도 있다고 가정한다.
	(체크섬, 순서 번호, 재전송은 도움은 되지만 근본적인 해결에는 충분하지 못한다.)
	(해결하지 못하는 이유는 깨진것이 아닌 중간에 사라진 것을 의미한다.)
	+ 해결책: 합리적인 시간 동안 송신자가 기다린다. (기다려도 안오면 재전송)
	1. 송신자가 충분한 시간 동안 ACK 수신을 기다린다.	
	(지정된 시간 동안 ACK를 받지 못하면 재전송한다.)
	
	2. 패킷(또는 ACK)가 손실이 아니고 지연된 경우라면, 재전송은 중복 패킷이 되지만 순서 번호를
	사용하여 이를 해결한다. 또한 수신자는 ACK 패킷의 순서 번호를 명시해야 한다.
	3. 카운트다운 타이머(타임 아웃 메카니즘이다)가 필요하다. (★★★★★★)